using System.Collections.Generic;
using System.IO;
using System.Text.Json.Nodes;

namespace HomeAssistantApps;

[NetDaemonApp]
public class GenerateGoogleYaml
{
    // CONFIGURATION
    private const string OutputPath = "/config/google_assistant.yaml";
    private const string EntityRegistryPath = "/config/.storage/core.entity_registry";
    private const string ConfigEntriesPath = "/config/.storage/core.config_entries";

    // Your static Google Assistant settings
    private const string ProjectId = "home-assistant-227322";
    private const string ServiceAccount = "!include service-account.json"; 
    private readonly ILogger<GenerateGoogleYaml> _logger;

    public GenerateGoogleYaml(InputButtonEntities buttonEntities, ILogger<GenerateGoogleYaml> logger)
    {
        _logger = logger;

        buttonEntities.GenerateGoogleYaml.StateChanges().Subscribe(_ => GenerateConfig());
    }

    private void GenerateConfig()
    {
        try
        {
            _logger.LogInformation("Starting Google Assistant YAML generation...");

            if (!File.Exists(EntityRegistryPath) || !File.Exists(ConfigEntriesPath))
            {
                _logger.LogError("Required registry files not found.");
                return;
            }

            // 1. Get List of Disabled Integrations (Config Entries)
            // We need to know which integrations are turned off so we can skip their entities.
            var configEntriesJson = File.ReadAllText(ConfigEntriesPath);
            var configEntriesNode = JsonNode.Parse(configEntriesJson)?["data"]?["entries"]?.AsArray();
            var disabledConfigEntryIds = new HashSet<string>();

            if (configEntriesNode != null)
            {
                foreach (var entry in configEntriesNode)
                {
                    // If "disabled_by" is not null (e.g. "user"), the integration is disabled.
                    if (entry?["disabled_by"] != null)
                    {
                        var entryId = entry["entry_id"]?.GetValue<string>();
                        if (!string.IsNullOrEmpty(entryId))
                        {
                            disabledConfigEntryIds.Add(entryId);
                        }
                    }
                }
            }

            // 2. Read Entity Registry
            var entityJson = File.ReadAllText(EntityRegistryPath);
            var entities = JsonNode.Parse(entityJson)?["data"]?["entities"]?.AsArray();

            if (entities == null) return;

            // 3. Filter and Build Config
            var entityConfigs = new List<string>();

            foreach (var entity in entities)
            {
                var entityId = entity?["entity_id"]?.GetValue<string>();
                if (string.IsNullOrEmpty(entityId)) continue;

                // CHECK A: Is the entity explicitly disabled? (e.g., by user)
                if (entity?["disabled_by"] != null)
                {
                    _logger.LogDebug("Skipping {EntityId}: Entity is disabled", entityId);
                    continue;
                }

                // CHECK B: Is the parent integration disabled?
                var configEntryId = entity?["config_entry_id"]?.GetValue<string>();
                if (!string.IsNullOrEmpty(configEntryId) && disabledConfigEntryIds.Contains(configEntryId))
                {
                    _logger.LogDebug("Skipping {EntityId}: Integration is disabled", entityId);
                    continue;
                }

                // CHECK C: Is it exposed to Assist?
                var options = entity?["options"]?["conversation"];
                var shouldExpose = options?["should_expose"]?.GetValue<bool>() ?? false;

                if (shouldExpose)
                {
                    var aliasesNode = entity?["aliases"]?.AsArray();
                    entityConfigs.Add(BuildEntityYaml(entityId, aliasesNode));
                }
            }

            // 4. Construct Final YAML
            var yamlContent = $@"# AUTOMATICALLY GENERATED BY NETDAEMON. DO NOT EDIT.
project_id: {ProjectId}
service_account: {ServiceAccount}
report_state: true
expose_by_default: false
entity_config:
{string.Join("\n", entityConfigs)}
";

            File.WriteAllText(OutputPath, yamlContent);
            _logger.LogInformation("Successfully wrote {Count} entities to {Path}", entityConfigs.Count, OutputPath);

            // 5. Request Sync
            //_ha.CallService("google_assistant", "request_sync");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to generate Google Assistant YAML");
        }
    }

    private string BuildEntityYaml(string entityId, JsonArray? aliases)
    {
        var sb = new System.Text.StringBuilder();
        sb.AppendLine($"  {entityId}:");
        sb.AppendLine($"    expose: true");
        
        if (aliases != null && aliases.Count > 0)
        {
            sb.AppendLine("    aliases:");
            foreach (var alias in aliases)
            {
                var aliasValue = alias?.GetValue<string>();
                if (!string.IsNullOrEmpty(aliasValue))
                {
                    sb.AppendLine($"      - {aliasValue}");
                }
            }
        }
        return sb.ToString().TrimEnd();
    }
}